<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Regular.woff2" as="font">
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Bold.woff2" as="font">
    
    
    
        <link rel="shortcut icon" href="/icons/favicon.ico">
    

    
    
        
<link rel="stylesheet" href="/css/mdui.min.v1.0.0.css">

    
    
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/iconfont.css">


    
    












          


    
    
    <title>
        
            kafka学习(二) | YS&#39;s Blog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.2.0"></head>
<body class="mdui-drawer-body-left mdui-appbar-with-toolbar mdui-theme-primary-teal mdui-theme-accent-blue">
  
  <header class="mdui-appbar mdui-appbar-fixed">
  <div id="toolbar" class="mdui-toolbar mdui-color-theme">
    <button class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="iconfont icon-menu"></i></button>
    <a href="/" class="mdui-typo-headline">YS&#39;s Blog</a>
    <a href="/" class="header-subtitle mdui-typo-headline"></a>
    <div class="mdui-toolbar-spacer"></div>
    <button class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'search'}"><i class="iconfont icon-search"></i></button>
  </div>
</header>

<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字" onfocus="listenSearchFunc()">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer">
    <div class="mdui-tab" mdui-tab>
        <a href="#sidebar-tab1" id="sidebartab" class="mdui-ripple mdui-tab-active">站点概览</a>
        <a href="#sidebar-tab2" id="sidebartab" class="mdui-ripple">关于</a>
    </div>

    
    <div id="sidebar-tab1" class="mdui-p-a-1">
        <div class="mdui-list">
            
                
                <a href="/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-home"></i>
                    </div>
                    <div class="mdui-list-item-content">主页</div>
                </a>
            
                
                <a href="/tags/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-bookmark"></i>
                    </div>
                    <div class="mdui-list-item-content">标签</div>
                </a>
            
                
                <a href="/categories/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-folder"></i>
                    </div>
                    <div class="mdui-list-item-content">分类</div>
                </a>
            
                
                <a href="/archives/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-archive"></i>
                    </div>
                    <div class="mdui-list-item-content">归档</div>
                </a>
            
                
                <a href="/tools/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-tools"></i>
                    </div>
                    <div class="mdui-list-item-content">工具箱</div>
                </a>
            
                
                <a href="/about/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-user"></i>
                    </div>
                    <div class="mdui-list-item-content">关于</div>
                </a>
            
            <div class="mdui-list-item mdui-ripple">
                <div class="mdui-list-item-icon">
                    <i class="iconfont icon-moon"></i>
                </div>
                <div class="mdui-list-item-content">夜间模式</div>
                <label class="mdui-switch" id="darkmode">
                  <input type="checkbox" id="nightmode_switch"/>
                  <i class="mdui-switch-icon"></i>
                </label>
            </div>           
        </div>
    </div>

    
    <div id="sidebar-tab2" class="mdui-p-a-1">
        <div class="sidebar-overview">
            <div class="sidebar-avatar">
                
                    <img src="/icons/avatar.gif"/>
                
            </div>
            <div class="sidebar-author-name">Yang Song</div>
            <div class="sidebar-description">努力学习的小白</div>
        </div>
        <div class="sidebar-links">
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-mail"></i></span>
                    <a href="mailto:1771209929@qq.com" class="mdui-chip-title">E-Mail</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-github"></i></span>
                    <a target="_blank" rel="noopener" href="https://github.com/YSRithe" class="mdui-chip-title">GitHub</a>
                </div>
            
        </div>
        <ul class="mdui-list" mdui-collapse="{accordion: true}">
            <li class="mdui-collapse-item">
                <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-link"></i>
                    </div>
                    <div class="mdui-list-item-content">友情链接</div>
                    <div class="mdui-collapse-item-arrow">
                        <i class="mdui-list-item-icon iconfont icon-angle-down"></i>
                    </div>
                </div>
                <ul id="linksList" class="mdui-collapse-item-body mdui-list mdui-list-dense">
                    
                        <a target="_blank" rel="noopener" href="https://garybear.cn/hexo-theme-meadow/" class="mdui-list-item mdui-ripple">
                            Meadow说明文档
                        </a>
                    
                </ul>
            </li>
        </ul>
    </div>

    <div class="mdui-divider"></div>
    
    
</aside>
  
  <main id="main-contain" class="mdui-container mdui-m-t-5">
    <article id="article" class="mdui-card mdui-p-b-2 mdui-m-b-5">
  <header class="mdui-card-media">
    
    
      <div class="post-header"> 
  <a class="post-header-title" href="/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/">kafka学习(二)</a>
  <div class="post-header-meta">
    <span>
      <span class="iconfont icon-calendar"></span>
      发布于:&nbsp;2021-01-10
    </span>
    <span>
      <span class="iconfont icon-calendar-check"></span>
      更新于:&nbsp;2021-01-10
    </span>
    <span>
      <span class="iconfont icon-folder"></span>
      分类于:&nbsp;<a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
    </span>
    
      <span>
        <span class="iconfont icon-eye"></span>
        阅读次数:&nbsp;
        <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
      </span>
    
  </div>
</div>   
    



    
    
    <div class="mdui-card-menu">
    
      <button class="mdui-btn mdui-btn-icon mdui-text-color-teal" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="iconfont icon-share"></i></button>
      <ul class="mdui-menu" id="share_menu">
        <li class="mdui-menu-item">
          <a href="http://service.weibo.com/share/share.php?appkey=&title=kafka学习(二)&url=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/&pic=http://example.com/null&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://twitter.com/intent/tweet?text=kafka学习(二)&url=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/&via=Yang Song" target="_blank" class="mdui-ripple">分享到 Twitter</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://plus.google.com/share?url=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/" target="_blank" class="mdui-ripple">分享到 Google+</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/&title=kafka学习(二)" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
        </li>
        <li class="mdui-menu-item">
          <a href="http://connect.qq.com/widget/shareqq/index.html?site=YS&#39;s Blog&title=kafka学习(二)&summary=努力学习的小白&pics=http://example.com/null&url=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/" target="_blank" class="mdui-ripple">分享到 QQ</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://telegram.me/share/url?url=http://example.com/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/&text=kafka学习(二)" target="_blank" class="mdui-ripple">分享到 Telegram</a>
        </li>
      </ul>
    
  </div>
  </header>
  
  
  
  
  <div class="post-tags">
    
      <i class="iconfont icon-tag">
        <a rel="tag" href = /tags/kafka/ >kafka</a>
      </i>
    
  </div>

  
  <div class="mdui-card-content mdui-typo mdui-p-x-4">
    <h2 id="四、broker-保存消息"><a href="#四、broker-保存消息" class="headerlink" title="四、broker 保存消息"></a><strong>四、broker 保存消息</strong></h2><h3 id="4-1-存储方式"><a href="#4-1-存储方式" class="headerlink" title="4.1 存储方式"></a><strong>4.1 存储方式</strong></h3><p>物理上把 topic 分成一个或多个 patition（对应 server.properties 中的 num.partitions=3 配置），每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件），如下：</p>
<p> <img src="https://images2015.cnblogs.com/blog/897247/201610/897247-20161012105133296-413851676.png" alt="img"></p>
<p>图.4</p>
<h3 id="4-2-存储策略"><a href="#4-2-存储策略" class="headerlink" title="4.2 存储策略"></a><strong>4.2 存储策略</strong></h3><p>无论消息是否被消费，kafka 都会保留所有消息。有两种策略可以删除旧数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 基于时间：log.retention.hours&#x3D;168</span><br><span class="line">2. 基于大小：log.retention.bytes&#x3D;1073741824</span><br></pre></td></tr></table></figure>

<p>需要注意的是，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。</p>
<h3 id="4-3-topic-创建与删除"><a href="#4-3-topic-创建与删除" class="headerlink" title="4.3 topic 创建与删除"></a><strong>4.3 topic 创建与删除</strong></h3><h4 id="4-3-1-创建-topic"><a href="#4-3-1-创建-topic" class="headerlink" title="4.3.1 创建 topic"></a><strong>4.3.1 创建 topic</strong></h4><p>创建 topic 的序列图如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/897247/201610/897247-20161012161552718-1963426687.png" alt="img"></p>
<p>图.5</p>
<p>流程说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. controller 在 ZooKeeper 的 &#x2F;brokers&#x2F;topics 节点上注册 watcher，当 topic 被创建，则 controller 会通过 watch 得到该 topic 的 partition&#x2F;replica 分配。</span><br><span class="line">2. controller从 &#x2F;brokers&#x2F;ids 读取当前所有可用的 broker 列表，对于 set_p 中的每一个 partition：</span><br><span class="line">	2.1 从分配给该 partition 的所有 replica（称为AR）中任选一个可用的 broker 作为新的 leader，并将AR设置为新的 ISR</span><br><span class="line">	2.2 将新的 leader 和 ISR 写入 &#x2F;brokers&#x2F;topics&#x2F;[topic]&#x2F;partitions&#x2F;[partition]&#x2F;state</span><br><span class="line">3. controller 通过 RPC 向相关的 broker 发送 LeaderAndISRRequest。</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-删除-topic"><a href="#4-3-2-删除-topic" class="headerlink" title="4.3.2 删除 topic"></a><strong>4.3.2 删除 topic</strong></h4><p>删除 topic 的序列图如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/897247/201610/897247-20161012162436140-850153613.png" alt="img"></p>
<p>图.6</p>
<p>流程说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. controller 在 zooKeeper 的 &#x2F;brokers&#x2F;topics 节点上注册 watcher，当 topic 被删除，则 controller 会通过 watch 得到该 topic 的 partition&#x2F;replica 分配。</span><br><span class="line">2. 若 delete.topic.enable&#x3D;false，结束；否则 controller 注册在 &#x2F;admin&#x2F;delete_topics 上的 watch 被 fire，controller 通过回调向对应的 broker 发送 StopReplicaRequest。</span><br></pre></td></tr></table></figure>



<h2 id="五、kafka-HA"><a href="#五、kafka-HA" class="headerlink" title="五、kafka HA"></a><strong>五、kafka HA</strong></h2><h3 id="5-1-replication"><a href="#5-1-replication" class="headerlink" title="5.1 replication"></a><strong>5.1 replication</strong></h3><p>如图.1所示，同一个 partition 可能会有多个 replica（对应 server.properties 配置中的 default.replication.factor=N）。没有 replica 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。引入replication 之后，同一个 partition 可能会有多个 replica，而这时需要在这些 replica 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replica 作为 follower 从 leader 中复制数据。</p>
<p>Kafka 分配 Replica 的算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将所有 broker（假设共 n 个 broker）和待分配的 partition 排序</span><br><span class="line">2. 将第 i 个 partition 分配到第（i mod n）个 broker 上</span><br><span class="line">3. 将第 i 个 partition 的第 j 个 replica 分配到第（(i + j) mode n）个 broker上</span><br></pre></td></tr></table></figure>

<h3 id="5-2-leader-failover"><a href="#5-2-leader-failover" class="headerlink" title="5.2 leader failover"></a><strong>5.2 leader failover</strong></h3><p>当 partition 对应的 leader 宕机时，需要从 follower 中选举出新 leader。在选举新leader时，一个基本的原则是，新的 leader 必须拥有旧 leader commit 过的所有消息。</p>
<p>kafka 在 zookeeper 中（/brokers/…/state）动态维护了一个 ISR（in-sync replicas），由3.3节的写入流程可知 ISR 里面的所有 replica 都跟上了 leader，只有 ISR 里面的成员才能选为 leader。对于 f+1 个 replica，一个 partition 可以在容忍 f 个 replica 失效的情况下保证消息不丢失。</p>
<p>当所有 replica 都不工作时，有两种可行的方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 等待 ISR 中的任一个 replica 活过来，并选它作为 leader。可保障数据不丢失，但时间可能相对较长。</span><br><span class="line">2. 选择第一个活过来的 replica（不一定是 ISR 成员）作为 leader。无法保障数据不丢失，但相对不可用时间较短。</span><br></pre></td></tr></table></figure>

<p>kafka 0.8.* 使用第二种方式。</p>
<p>kafka 通过 Controller 来选举 leader，流程请参考5.3节。</p>
<h3 id="5-3-broker-failover"><a href="#5-3-broker-failover" class="headerlink" title="5.3 broker failover"></a><strong>5.3 broker failover</strong></h3><p>kafka broker failover 序列图如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/897247/201610/897247-20161012143318812-1534130173.png" alt="img"></p>
<p>图.7</p>
<p>流程说明： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. controller 在 zookeeper 的 &#x2F;brokers&#x2F;ids&#x2F;[brokerId] 节点注册 Watcher，当 broker 宕机时 zookeeper 会 fire watch</span><br><span class="line">2. controller 从 &#x2F;brokers&#x2F;ids 节点读取可用broker</span><br><span class="line">3. controller决定set_p，该集合包含宕机 broker 上的所有 partition</span><br><span class="line">4. 对 set_p 中的每一个 partition</span><br><span class="line">    4.1 从&#x2F;brokers&#x2F;topics&#x2F;[topic]&#x2F;partitions&#x2F;[partition]&#x2F;state 节点读取 ISR</span><br><span class="line">    4.2 决定新 leader（如4.3节所描述）</span><br><span class="line">    4.3 将新 leader、ISR、controller_epoch 和 leader_epoch 等信息写入 state 节点</span><br><span class="line">5. 通过 RPC 向相关 broker 发送 leaderAndISRRequest 命令</span><br></pre></td></tr></table></figure>

<h3 id="5-4-controller-failover"><a href="#5-4-controller-failover" class="headerlink" title="5.4 controller failover"></a><strong>5.4 controller failover</strong></h3><p> 当 controller 宕机时会触发 controller failover。每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p>
<p>当新的 controller 当选时，会触发 KafkaController.onControllerFailover 方法，在该方法中完成如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 读取并增加 Controller Epoch。</span><br><span class="line">2. 在 reassignedPartitions Patch(&#x2F;admin&#x2F;reassign_partitions) 上注册 watcher。</span><br><span class="line">3. 在 preferredReplicaElection Path(&#x2F;admin&#x2F;preferred_replica_election) 上注册 watcher。</span><br><span class="line">4. 通过 partitionStateMachine 在 broker Topics Patch(&#x2F;brokers&#x2F;topics) 上注册 watcher。</span><br><span class="line">5. 若 delete.topic.enable&#x3D;true（默认值是 false），则 partitionStateMachine 在 Delete Topic Patch(&#x2F;admin&#x2F;delete_topics) 上注册 watcher。</span><br><span class="line">6. 通过 replicaStateMachine在 Broker Ids Patch(&#x2F;brokers&#x2F;ids)上注册Watch。</span><br><span class="line">7. 初始化 ControllerContext 对象，设置当前所有 topic，“活”着的 broker 列表，所有 partition 的 leader 及 ISR等。</span><br><span class="line">8. 启动 replicaStateMachine 和 partitionStateMachine。</span><br><span class="line">9. 将 brokerState 状态设置为 RunningAsController。</span><br><span class="line">10. 将每个 partition 的 Leadership 信息发送给所有“活”着的 broker。</span><br><span class="line">11. 若 auto.leader.rebalance.enable&#x3D;true（默认值是true），则启动 partition-rebalance 线程。</span><br><span class="line">12. 若 delete.topic.enable&#x3D;true 且Delete Topic Patch(&#x2F;admin&#x2F;delete_topics)中有值，则删除相应的Topic。</span><br></pre></td></tr></table></figure>

<h2 id="6-consumer-消费消息"><a href="#6-consumer-消费消息" class="headerlink" title="6. consumer 消费消息"></a><strong>6. consumer 消费消息</strong></h2><h3 id="6-1-consumer-API"><a href="#6-1-consumer-API" class="headerlink" title="6.1 consumer API"></a><strong>6.1 consumer API</strong></h3><p>kafka 提供了两套 consumer API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. The high-level Consumer API</span><br><span class="line">2. The SimpleConsumer API</span><br></pre></td></tr></table></figure>

<p> 其中 high-level consumer API 提供了一个从 kafka 消费数据的高层抽象，而 SimpleConsumer API 则需要开发人员更多地关注细节。</p>
<h4 id="6-1-1-The-high-level-consumer-API"><a href="#6-1-1-The-high-level-consumer-API" class="headerlink" title="6.1.1 The high-level consumer API"></a><strong>6.1.1 The high-level consumer API</strong></h4><p>high-level consumer API 提供了 consumer group 的语义，一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 zookeeper 保存。</p>
<p>使用 high-level consumer API 可以是多线程的应用，应当注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果消费线程大于 patition 数量，则有些线程将收不到消息</span><br><span class="line">2. 如果 patition 数量大于线程数，则有些线程多收到多个 patition 的消息</span><br><span class="line">3. 如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而一个 patition 内的消息是有序的</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-The-SimpleConsumer-API"><a href="#6-1-2-The-SimpleConsumer-API" class="headerlink" title="6.1.2 The SimpleConsumer API"></a><strong>6.1.2 The SimpleConsumer API</strong></h4><p>如果你想要对 patition 有更多的控制权，那就应该使用 SimpleConsumer API，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 多次读取一个消息</span><br><span class="line">2. 只消费一个 patition 中的部分消息</span><br><span class="line">3. 使用事务来保证一个消息仅被消费一次</span><br></pre></td></tr></table></figure>

<p> 但是使用此 API 时，partition、offset、broker、leader 等对你不再透明，需要自己去管理。你需要做大量的额外工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 必须在应用程序中跟踪 offset，从而确定下一条应该消费哪条消息</span><br><span class="line">2. 应用程序需要通过程序获知每个 Partition 的 leader 是谁</span><br><span class="line">3. 需要处理 leader 的变更</span><br></pre></td></tr></table></figure>

<p> 使用 SimpleConsumer API 的一般流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 查找到一个“活着”的 broker，并且找出每个 partition 的 leader</span><br><span class="line">2. 找出每个 partition 的 follower</span><br><span class="line">3. 定义好请求，该请求应该能描述应用程序需要哪些数据</span><br><span class="line">4. fetch 数据</span><br><span class="line">5. 识别 leader 的变化，并对之作出必要的响应</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下针对 high-level Consumer API 进行说明。</p>
</blockquote>
<h3 id="6-2-consumer-group"><a href="#6-2-consumer-group" class="headerlink" title="6.2 consumer group"></a><strong>6.2 consumer group</strong></h3><p>如 2.2 节所说， kafka 的分配单位是 patition。每个 consumer 都属于一个 group，一个 partition 只能被同一个 group 内的一个 consumer 所消费（也就保障了一个消息只能被 group 内的一个 consuemr 所消费），但是多个 group 可以同时消费这个 partition。</p>
<p>kafka 的设计目标之一就是同时实现离线处理和实时处理，根据这一特性，可以使用 spark/Storm 这些实时处理系统对消息在线处理，同时使用 Hadoop 批处理系统进行离线处理，还可以将数据备份到另一个数据中心，只需要保证这三者属于不同的 consumer group。如下图所示：</p>
<p> <img src="https://images2015.cnblogs.com/blog/897247/201610/897247-20161012104850453-563375248.png" alt="img"></p>
<p>图.8</p>
<h2 id="6-3-消费方式"><a href="#6-3-消费方式" class="headerlink" title="6.3 消费方式"></a><strong>6.3 消费方式</strong></h2><p>consumer 采用 pull 模式从 broker 中读取数据。</p>
<p>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p>
<p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>
<h3 id="6-4-consumer-delivery-guarantee"><a href="#6-4-consumer-delivery-guarantee" class="headerlink" title="6.4 consumer delivery guarantee"></a><strong>6.4 consumer delivery guarantee</strong></h3><p>如果将 consumer 设置为 autocommit，consumer 一旦读到数据立即自动 commit。如果只讨论这一读取消息的过程，那 Kafka 确保了 Exactly once。</p>
<p>但实际使用中应用程序并非在 consumer 读取完数据就结束了，而是要进行进一步处理，而数据处理与 commit 的顺序在很大程度上决定了consumer delivery guarantee：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.读完消息先 commit 再处理消息。</span><br><span class="line">    这种模式下，如果 consumer 在 commit 后还没来得及处理消息就 crash 了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于 At most once</span><br><span class="line">2.读完消息先处理再 commit。</span><br><span class="line">    这种模式下，如果在处理完消息之后 commit 之前 consumer crash 了，下次重新开始工作时还会处理刚刚未 commit 的消息，实际上该消息已经被处理过了。这就对应于 At least once。</span><br><span class="line">3.如果一定要做到 Exactly once，就需要协调 offset 和实际操作的输出。</span><br><span class="line">    精典的做法是引入两阶段提交。如果能让 offset 和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer 拿到数据后可能把数据放到 HDFS，如果把最新的 offset 和数据本身一起写到 HDFS，那就可以保证数据的输出和 offset 的更新要么都完成，要么都不完成，间接实现 Exactly once。（目前就 high-level API而言，offset 是存于Zookeeper 中的，无法存于HDFS，而SimpleConsuemr API的 offset 是由自己去维护的，可以将之存于 HDFS 中）</span><br></pre></td></tr></table></figure>

<p>总之，Kafka 默认保证 At least once，并且允许通过设置 producer 异步提交来实现 At most once（见文章《<a target="_blank" rel="noopener" href="http://kane-xie.iteye.com/blog/2225085">kafka consumer防止数据丢失</a>》）。而 Exactly once 要求与外部存储系统协作，幸运的是 kafka 提供的 offset 可以非常直接非常容易得使用这种方式。</p>
<p>更多关于 kafka 传输语义的信息请参考《<a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation.html#semantics">Message Delivery Semantics</a>》。</p>
<h3 id="6-5-consumer-rebalance"><a href="#6-5-consumer-rebalance" class="headerlink" title="\6.5 consumer rebalance**"></a><strong><em>\</em>6.5 consumer rebalance**</strong></h3><p>当有 consumer 加入或退出、以及 partition 的改变（如 broker 加入或退出）时会触发 rebalance。consumer rebalance算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 将目标 topic 下的所有 partirtion 排序，存于PT</span><br><span class="line">2. 对某 consumer group 下所有 consumer 排序，存于 CG，第 i 个consumer 记为 Ci</span><br><span class="line">3. N&#x3D;size(PT)&#x2F;size(CG)，向上取整</span><br><span class="line">4. 解除 Ci 对原来分配的 partition 的消费权（i从0开始）</span><br><span class="line">5. 将第i*N到（i+1）*N-1个 partition 分配给 Ci</span><br></pre></td></tr></table></figure>

<p>在 0.8.*版本，每个 consumer 都只负责调整自己所消费的 partition，为了保证整个consumer group 的一致性，当一个 consumer 触发了 rebalance 时，该 consumer group 内的其它所有其它 consumer 也应该同时触发 rebalance。这会导致以下几个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Herd effect</span><br><span class="line">　　任何 broker 或者 consumer 的增减都会触发所有的 consumer 的 rebalance</span><br><span class="line">2.Split Brain</span><br><span class="line">　　每个 consumer 分别单独通过 zookeeper 判断哪些 broker 和 consumer 宕机了，那么不同 consumer 在同一时刻从 zookeeper 看到的 view 就可能不一样，这是由 zookeeper 的特性决定的，这就会造成不正确的 reblance 尝试。</span><br><span class="line">3. 调整结果不可控</span><br><span class="line">　　所有的 consumer 都并不知道其它 consumer 的 rebalance 是否成功，这可能会导致 kafka 工作在一个不正确的状态。</span><br></pre></td></tr></table></figure>

<p>基于以上问题，kafka 设计者考虑在0.9.*版本开始使用中心 coordinator 来控制 consumer rebalance，然后又从简便性和验证要求两方面考虑，计划在 consumer 客户端实现分配方案。（见文章《<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Detailed+Consumer+Coordinator+Design#KafkaDetailedConsumerCoordinatorDesign-WARN:Thisisanobsoletedesign.Thedesignthat'simplementedinKafka0.9.0isdescribedinthiswiki.">Kafka Detailed Consumer Coordinator Design</a>》和《<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Client-side+Assignment+Proposal">Kafka Client-side Assignment Proposal</a>》），此处不再赘述。</p>

  </div>
  <!--文末结束语-->
  
    <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="iconfont icon-heartbeat" style="font-size:24px;"></i> The End --- </div>
  
  <!--页脚广告-->
  
  <div class="mdui-divider"></div>
  
  <nav>
    
    
      <a rel="next" class="post-nav-item mdui-float-right" href="/2021/01/07/kafka%E5%AD%A6%E4%B9%A0/">
        <span>kafka学习</span>
        <i class="iconfont icon-angle-right"></i>
      </a>
    
  </nav>
</article>




  <div class="toc-button"  style="z-index: 100;">
    <button class="mdui-fab mdui-ripple mdui-color-teal" mdui-menu="{target: '#toc'}"><i class="iconfont icon-list"></i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item">
        <a href="/2021/01/10/kafka%E5%AD%A6%E4%B9%A0%E4%BA%8C/" id="toc-header" class="mdui-ripple">文章目录</a>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81broker-%E4%BF%9D%E5%AD%98%E6%B6%88%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">四、broker 保存消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 存储策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-topic-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 topic 创建与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%88%9B%E5%BB%BA-topic"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.3.1 创建 topic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%88%A0%E9%99%A4-topic"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.3.2 删除 topic</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81kafka-HA"><span class="toc-number">2.</span> <span class="toc-text">五、kafka HA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-replication"><span class="toc-number">2.1.</span> <span class="toc-text">5.1 replication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-leader-failover"><span class="toc-number">2.2.</span> <span class="toc-text">5.2 leader failover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-broker-failover"><span class="toc-number">2.3.</span> <span class="toc-text">5.3 broker failover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-controller-failover"><span class="toc-number">2.4.</span> <span class="toc-text">5.4 controller failover</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-consumer-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">3.</span> <span class="toc-text">6. consumer 消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-consumer-API"><span class="toc-number">3.1.</span> <span class="toc-text">6.1 consumer API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-The-high-level-consumer-API"><span class="toc-number">3.1.1.</span> <span class="toc-text">6.1.1 The high-level consumer API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-The-SimpleConsumer-API"><span class="toc-number">3.1.2.</span> <span class="toc-text">6.1.2 The SimpleConsumer API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-consumer-group"><span class="toc-number">3.2.</span> <span class="toc-text">6.2 consumer group</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">6.3 消费方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-consumer-delivery-guarantee"><span class="toc-number">4.1.</span> <span class="toc-text">6.4 consumer delivery guarantee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-consumer-rebalance"><span class="toc-number">4.2.</span> <span class="toc-text">\6.5 consumer rebalance**</span></a></li></ol></li></ol>
      </li>
    </ul>
  </div>



    <div id="comment" class="mdui-card mdui-p-a-2 mdui-m-b-5">
      <div class="mdui-tab" mdui-tab>
        
          <a href="#comment-tab0" class="mdui-ripple">gitalk</a>
        
          <a href="#comment-tab1" class="mdui-ripple">livere</a>
        
      </div>
      
        <div id="comment-tab0" class="mdui-p-a-2">
          <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    id:  md5(location.pathname) ,
    distractionFreeMode: 'true',
  });
  gitalk.render('gitalk-container');
</script>
        </div>
      
        <div id="comment-tab1" class="mdui-p-a-2">
          <div id="lv-container" data-id="city" data-uid="">
  <script type="text/javascript">
    (function (d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>
  <noscript>Please enable JavaScript to view the comments powered by LiveRe.</noscript>
</div>
        </div>
      
    </div>

  </main>
  <footer id="footer" class="mdui-text-center mdui-m-t-5 mdui-p-b-2 mdui-p-t-4 mdui-color-theme">
  <div class="mdui-container">
    <div class="mdui-row">
      
        <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank"></a>
      
      <span>
        &copy; 2015 - 2021 
        
          <span style="color:#d9333f" class="iconfont icon-heart"></span>
        
        Yang Song
      </span>
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span>Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span>Theme: <a href="https://github.com/kb1000fx/Meadow" rel="noopener" target="_blank">Meadow</a></span>
        </div>
      
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span id="busuanzi_container_site_uv" style="display: none;"> <span class="iconfont icon-user"></span>总访客量 <span id="busuanzi_value_site_uv"></span></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span id="busuanzi_container_site_pv" style="display: none;"> <span class="iconfont icon-eye"></span>总访问量 <span id="busuanzi_value_site_pv"></span></span>
        </div>
      
    </div>
 </div>
</footer>
  
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-teal" style="z-index:100;"><i class="iconfont icon-arrowup"></i></button>
  
  

    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>




    
<script src="/js/mdui.min.v1.0.0.js"></script>




<script src="/js/meadow.js"></script>

</body>
</html >